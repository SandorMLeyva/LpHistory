%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[twoside,twocolumn]{article}
\usepackage{polyglossia}
\setmainlanguage{spanish}
\usepackage{blindtext} % Package to generate dummy text throughout this template 

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

%\usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{LP $\bullet$ Dec 2019 $\bullet$ Vol. XXI, No. 1} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section

\usepackage{hyperref} % For hyperlinks in the PDF

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\Huge\bfseries} % Article title formatting
\posttitle{\end{center}} % Article title closing formatting
\title{Evolución de los Lenguajes de Programación} % Article title
\author{%
\textsc{Leandro González Montesino}\thanks{Estudiante del grupo C-511} \\[1ex] % Your name
\textsc{Sandor Martín}\thanks{Estudiante del grupo C-512} \\[1ex]
\normalsize Universidad de la Habana \\ % Your institution
\normalsize \href{mailto:l.montesino@estudiantes.matcom.uh.cu}{l.montesino@estudiantes.matcom.uh.cu}\\ % Your email address
\normalsize \href{mailto:s.martin@estudiantes.matcom.uh.cu}{s.martin@estudiantes.matcom.uh.cu}
%\and % Uncomment if 2 authors are required, duplicate these 4 lines if more
%\textsc{Jane Smith}\thanks{Corresponding author} \\[1ex] % Second author's name
%\normalsize University of Utah \\ % Second author's institution
%\normalsize \href{mailto:jane@smith.com}{jane@smith.com} % Second author's email address
}
\date{\today} % Leave empty to omit a date
\renewcommand{\maketitlehookd}{%
\begin{abstract}
\noindent El conjunto de órdenes e instrucciones que se dan al
ordenador para que resuelva un problema o ejecute una
determinada misión, recibe el nombre de programa. En
los primeros tiempos de la informática, la programación
se efectuaba en el único lenguaje que entiende el micro-
procesador: su propio código binario, también denomi-
nado lenguaje máquina o código máquina.
Pero la programación en lenguaje máquina resulta
muy lenta y tediosa, pues los datos e instrucciones se
deben introducir en sistema binario y, además, obliga a
conocer las posiciones de memoria donde se almace-
nan los datos. Como puede imaginar, este tipo de pro-
gramación conlleva gran número de errores y la tarea
de depuración exige bastante tiempo y dedicación.¿Y cuántos lenguajes de programación existen?
Pues sucede algo así como con los lenguajes humanos:
existen centenares, si bien sólo unos pocos de ellos son
ampliamente utilizados. En este artículo me voy a cen-
trar en los lenguajes de programación más difundidos,
siguiendo un criterio cronológico, y lo finalizaré presen-
tándole una somera relación de otros lenguajes de pro-
gramación más minoritarios o que ya han caído en
desuso?
\end{abstract}
}

%----------------------------------------------------------------------------------------

\begin{document}

% Print the title
\maketitle

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{Introducción}

\lettrine[nindent=0em,lines=3]{L} os lenguajes de programación.


%------------------------------------------------

\section{Historia}

En la década de 1940 fueron creadas las primeras computadoras modernas, con alimentación eléctrica. La velocidad y capacidad de memoria limitadas forzaron a los programadores a escribir programas, en lenguaje ensamblador muy afinados. Finalmente se dieron cuenta de que la programación en lenguaje ensamblador requería de un gran esfuerzo intelectual y era muy propensa a errores.

En 1948, Konrad Zuse publicó un artículo acerca de su lenguaje de programación \textit{Plankalkül}. Sin embargo, no fue implementado en su vida y sus contribuciones fueron aisladas de otros desarrollos.

Entre algunos lenguajes importantes que fueron desarrollados en este período se encuentran: 
\begin{itemize}
\item     1943 - \textit{Plankalkül} (Respetad a Conrado), diseñado, pero sin implementar durante medio siglo.
\item   1943 - se crea el sistema de codificación ENIAC.
\item  1949 - 1954 -- una serie de conjuntos de instrucciones nemotécnicas, como la de ENIAC, comenzando en 1949 con C-10 para BINAC (que luego evolucionaría en UNIVAC). Cada conjunto de instrucciones estaba destinado a un fabricante específico.
\end{itemize}




%------------------------------------------------

\section{Intérpretes y compiladores}

Antes de pasar a ver los principales lenguajes de
programación, debemos hacer un alto para comentar
una característica común a todos ellos: las órdenes
dadas en cualquier lenguaje siempre deben traducirse
al código binario del ordenador, que es el único que
realmente comprende su unidad central. Esta labor de
traducción se lleva a cabo mediante un intérprete o un
compilador. ¿Y qué diferencia hay entre estas dos
cosas? Retomemos el símil de los lenguajes humanos y
todo quedará aclarado.

Imagine que no sabe nada de inglés y necesita conversar con alguien que sólo conoce ese idioma. La
forma más sencilla de establecer comunicación es conseguir una persona que ejerza de intérprete. Cuando
diga una frase en castellano, su intérprete la traducirá
al inglés y, de esta forma, podrá entenderla aquella
persona con la que esté conversando; análogo proceso
se seguirá para traducir del inglés al castellano. En
resumen, mientras esté presente su intérprete, la conversación es posible.

El intérprete informático realiza, más o menos, el
mismo papel. Traduce instrucción a instrucción y, de
esta forma, favorece la interactividad, la depuración y
puesta a punto del programa, la ejecución inmediata
de una orden, etc. Por ejemplo, entre los lenguajes que
suelen ser interpretados, se encuentran BASIC, LOGO, Python, Ruby, entre otros.

No obstante, existe otro tipo de traducción, la escrita, que presenta diferencias con respecto a la traducción oral. Suponga, por ejemplo, que uno de sus libros
vaya a ser editado en Gran Bretaña. Desde luego, no
tiene sentido que, quien compre su libro, tenga un
intérprete cerca cada vez que desee leer su libro. Resulta más lógico traducir el libro al inglés, ¿no? Cuando el
traductor haya finalizado su trabajo, se tendrán dos
copias del libro; el original, en castellano, y su traducción, en inglés, que ya puede ser leída por cualquier
persona que conozca el idioma de Shakespeare, sin
necesidad de intérprete a su lado.

El equivalente informático de esta modalidad de
traductor se denomina compilador\footnote{La introducción del término compilador (compiler, en inglés) en informática, se debe a la pionera Grace Hopper, que designó con ese nombre a su programa traductor A-O (1949). Más tarde, desarrolló el compilador B-O para UNIVAC.} . Observe que, en
contraste con el intérprete, que traduce las instrucciones una a una, el compilador traduce todo el programa
de golpe, dejándolo listo para ser ejecutado\footnote{Se llama programa fuente al programa original y programa objeto al programa resultante de la traducción.} . De esta
forma, se logra mayor rapidez en la ejecución y, además, se liberan recursos de la memoria, pues el programa, una vez compilado, no exige que el traductor esté
residente en memoria, como sucede con los intérpretes.





%------------------------------------------------


%------------------------------------------------
\section{Leanguajes}

\subsection{Fortran}

Al comienzo de la década de los 50, John Backus
estaba trabajando con \textit{SSEC (Selective Sequence Electronic Calculator)}, uno de los primeros ordenadores de
\textit{\textit{IBM}}, y desarrolló el programa \textit{SPEEDCODING} para él.
Tomando éste como base, se emprendió, en otoño de
1954, la creación de un lenguaje para añadirle más
prestaciones al modelo \textit{IBM} 704, que iba a salir pronto
al mercado.

En 1956 se terminó el compilador FORTRAN
\textit{(\textbf{FOR}mula \textbf{TRAN}slator)} y se incluyó en el \textit{IBM} 704,
junto con un manual de 51 páginas.
Como su nombre indica, FORTRAN estaba (y está)
destinado a la resolución de problemas científico-técnicos, resultando relativamente sencillo de aprender si se
domina la notación matemática.

Aunque ha ido perfeccionándose a lo largo del
tiempo (con sus versiones II, IV, 77 y 90), lo cierto es
que se ha visto superado por otros muchos lenguajes,
ya que sus programas carecen de estructuración y son
difíciles de seguir. Sin embargo, todavía se
sigue utilizando, sobre todo en el ámbito universitario.
¿Por qué? La respuesta radica en la gran biblioteca de
subrutinas y funciones que se ha ido creando en sus
más de treinta años de existencia.

\subsection{ALGOL}

Se denomina ALGOL (o Algol) a un lenguaje de programación. La voz es un acrónimo de las palabras inglesas \textit{Algorithmic Language} (lenguaje algorítmico). Fue muy popular en las universidades durante los años 60, pero no llegó a cuajar como lenguaje de utilización comercial. Sin embargo, Algol influyó profundamente en varios lenguajes posteriores que sí alcanzaron gran difusión, como Pascal, C y Ada.

Hacia 1965 dos corrientes se distinguieron sobre el tema de un sucesor para Algol. Como resultado se definieron los lenguajes Algol W que es un lenguaje minimalista, rápidamente implementado y distribuido y, por otra parte, Algol 68 que para la época está en la frontera entre un lenguaje para programar en él y un lenguaje para investigar sobre él.


\begin{figure}[h]
\label{Fig1}
\caption[al.png]{Ejemplo de programa en ALGOL 60 }
\end{figure}

\subsection{Lisp}

El Lisp (o LISP) es una familia de lenguajes de programación de computadora de tipo multiparadigma con una larga historia y una sintaxis completamente entre paréntesis.

Especificado originalmente en 1958 por John McCarthy y sus colaboradores en el Instituto Tecnológico de Massachusetts, el Lisp es el segundo más viejo lenguaje de programación de alto nivel de extenso uso hoy en día; solamente el FORTRAN es más viejo.

Al igual que el FORTRAN, Lisp ha cambiado mucho desde sus comienzos, y han existido un gran número de dialectos en su historia. Hoy, los dialectos Lisp de propósito general más ampliamente conocidos son el \textit{Common Lisp y el Scheme}.

El Lisp fue creado originalmente como una notación matemática práctica para los programas de computadora, basada en el cálculo lambda de Alonzo Church. Se convirtió rápidamente en el lenguaje de programación favorito en la investigación de la inteligencia artificial \textit{(AI)}. Como uno de los primeros lenguajes de programación, Lisp fue pionero en muchas ideas en ciencias de la computación, incluyendo las estructuras de datos de árbol, el manejo de almacenamiento automático, tipos dinámicos, y el compilador auto contenido.

El nombre LISP deriva del \textit{LISt Processing} (Proceso de LIStas). Las listas encadenadas son una de las estructuras de datos importantes del Lisp, y el código fuente del Lisp en sí mismo está compuesto de listas. Como resultado, los programas de Lisp pueden manipular el código fuente como una estructura de datos, dando lugar a los macro sistemas que permiten a los programadores crear una nueva sintaxis de lenguajes de programación de dominio específico empotrados en el Lisp.

\subsection{COBOL}

A finales de los 50, el Departamento de Defensa
USA estaba bastante preocupado con los lenguajes de
programación existentes, especialmente por dos razo-
nes: los programas no podían llevarse de un ordenador
a otro y resultaban bastante difíciles de leer y modificar.
Para solventar estos inconvenientes, patrocinó una
conferencia sobre lenguajes \textit{(CODASYL, \textbf{CO}nference
on \textbf{DA}ta \textbf{SY}stems \textbf{L}anguages)}, que tuvo lugar en 1959
y en la que participaron las grandes empresas del sector (\textit{IBM, Sperry Rand, Honey Well}, etc.). Como era
previsible, formaba parte del comité la gran dama de la
informática,

El lenguaje COBOL \textit{(acrónimo de \textbf{CO}mmon \textbf{B}usiness-\textbf{O}riented \textbf{L}anguage, Lenguaje Común Orientado a Negocios)} fue creado en el año 1959 con el objetivo de crear un lenguaje de programación universal que pudiera ser usado en cualquier ordenador (ya que en los años 1960 existían numerosos modelos de ordenadores incompatibles entre sí), y que estuviera orientado principalmente a los negocios, es decir, a la llamada informática de gestión.

\subsection{SIMULA}

Simula es un lenguaje de programación orientada a objetos (OOP) de 1962. Fue el primero de este tipo que incluyó el concepto de clase. Varios años después de su desarrollo, casi todos los lenguajes modernos comenzaron a utilizar sus principios de orientación a objetos. Así fue como se popularizaron términos como clases, objetos, instancias, herencia, polimorfismo, etc.

Simula 67 fue lanzado oficialmente por sus autores Ole Johan Dahl y Kristen Nygaard en mayo de 1967, en la Conferencia de Trabajo en Lenguajes de Simulación IFIO TC 2, en Lysebu cerca de Oslo

Hoy en día, los creadores de Simula han desarrollado un nuevo lenguaje de programación, llamado Beta, que generaliza todas las construcciones del lenguaje en una única idea denominada patrón.

\subsection{Basic}

En la programación de computadoras, siglas de Beginner's All-purpose Symbolic Instruction Code[1] (Código simbólico de instrucciones de propósito general para principiantes en español), es una familia de lenguajes de programación de alto nivel. El BASIC original, el Dartmouth BASIC, fue diseñado en 1964 por John George Kemeny y Thomas Eugene Kurtz en el Dartmouth College en Nuevo Hampshire, Estados Unidos, como un medio para facilitar la programación en ordenadores a estudiantes (y profesores) que no fueran de ciencias. De aquella, casi todo el uso de los ordenadores requería codificar software hecho a medida, con lo cual quedaba restringida a personas con formación como científicos y matemáticos. BASIC originalmente fue desarrollado como una herramienta de enseñanza. El lenguaje y sus variantes llegaron a estar ampliamente disponibles en los microcomputadores a finales de los años 1970 y en los años 1980. BASIC sigue siendo popular a día de hoy en un puñado de dialectos altamente modificados, y en nuevos lenguajes, influenciados por BASIC tales como Microsoft Visual Basic o Gambas en GNU/Linux. En el año 2006, el 59 porciento de los desarrolladores para la plataforma .NET usaban Visual Basic .NET como su único lenguaje.[2]

Es importante aclarar que una de las grandes desventajas en comparación con lenguajes como COBOL, RPG es que no maneja como parte integrada el acceso a archivos directos o RANDOM. Se tenía que apoyar en una aplicación externa para poder acceder de manera directa un registro de algún archivo.

\subsection{B}
Fue publicado entre 1969-1970, diseñado por Kenneth L. Thompson con ayuda de Dennis M. Ritchie en los laboratorios de Bell (New Jersey). Se creó con el objetivo de que cupiese en las memorias de las minicomputadoras del momento. Solo tenía cuatro tipos de datos del tamaño de una palabra de máquina los cuales en el fondo eran enteros. Ofrecía operadores que permitían obtener la dirección en memoria de una determinada variable, o escribir en una dirección determinada. A estos valores que apuntaban a direcciones de memoria se les llamó punteros.

\subsection{C}
En 1972 fue creado C por Dennis M. Ritchie, a partir del lenguaje B creado por su compañero Kenneth L. Thomps. Es un lenguaje de propósito general que ofrece economía sintáctica, control de flujos y un buen conjunto de operadores. Es uno de los lenguajes más portables del mercado y dada su gran eficiencia, ha tenido gran aceptación entre los programadores. En 1973 el lenguaje tenía tanta aceptación y era tan bueno que se decidió reescribir la mayor parte del \textit{kernel} de UNIX en C. Este fue uno de los primeros núcleos de sistemas operativos implementados en un lenguaje distinto al ensamblador.

\subsection{Pascal}

Niklaus Wirth, profesor del Instituto Politécnico Federal Suizo comenzó la creación de Pascal en 1970 y no fue su formalización hasta 1980 y su estandarización en 1983. El objetivo de este lenguaje fue ser fácil de aprender y al mismo tiempo potente que seguía las pautas de la programación estructurada. Este se derivó de ALGOL y posibilitaba el uso de recursividad, punteros, entre otras características de los lenguajes de programación. Borland lanzó al mercado su compilador con el nombre de Turbo-Pascal con el objetivo de acentuar su rapidez, el cual fue un gran éxito. En el año 1995 salió a la luz una nueva versión llamada Delphi ampliando los horizontes de Pascal hacia la programación visual. Lamentablemente Borland no le dio más soporte a Turbo-Pascal a partir del año 2000 por lo que su uso ha ido decreciendo con el tiempo viéndose solamente en ambientes universitarios.


\subsection{Modula}
Modula-2 fue diseñado por Niklaus Wirth (diseñador de Pascal). Influido por Pascal como es de esperar, introdujo el concepto de módulo y encapsulación el cual sirvió de referencia para las clases y objetos que se tiene en los lenguajes modernos orientados a objetos, aunque a Modula-2 no se le consideraba orientado a objetos. Su uso ha sido mayormente en las universidades por su adaptación a la enseñanza de los lenguajes estructurados. Pero en el ámbito laboral tiene como rival directo a C el cual no cede su predominio.

Modula-3 fue diseñado a finales de los 80s en \textit{Systems Research Center} y en Olivetti, por Luca Cardelli, Jim Donahe, Mick Jordan, Bill Kalsow y Greg Nelson. Como es de esperar su diseño fue inspirado por Modula-2. Su objetivo era continuar la tradición de Pascal y añadir nuevas construcciones para llevar a cabo una programación práctica, implementando características de los lenguajes operativos del momento de un modo simple. Evitando la herencia múltiple y la sobrecarga de operadores por el riesgo que estas suponen. El lenguaje ganó terreno en el ámbito docente durante los 90s, aunque no fue de esta forma para usos industriales. La desaparición de \textit{Digital Equipment Corporation (DEC)} significó un duro golpe para el desarrollo del lenguaje debido a que estos era uno de sus principales desarrolladores. Debido a su fácil implementación de las características de los lenguajes de programación, lenguajes más recientes como Java y Python lo tomaron como un punto de referencia.


\subsection{Meta Lenguaje}

ML es un lenguaje de programación de propósito general de la familia de los lenguajes de programación funcional desarrollado por Robin Milner y otros a finales de los años 1970 en la Universidad de Edimburgo. ML es el acrónimo inglés de metalenguaje dado que fue concebido como el lenguaje para desarrollar tácticas de demostración en el sistema LCF (El lenguaje para el cual ML era metalenguaje es pplambda, una combinación del cálculo de predicados de primer orden y el lambda-cálculo polimórfico sencillamente tipificado).

Frecuentemente se clasifica a ML como un lenguaje funcional impuro dado que permite programar imperativamente con efecto colateral, a diferencia de otros lenguajes de programación funcional, tales como Haskell.

Entre las características de ML se incluyen evaluación por valor, álgebra de funciones, manejo automatizado de memoria por medio de recolección de basura, polimorfismo parametrizado, análisis de estático de tipos, inferencia de tipos, tipos de datos algebraicos, llamada por patrones y manejo de excepciones. Esta combinación particular de conceptos hace que sea posible producir una de los mejores compiladores actualmente disponibles.

\subsection{Smalltalk}
Creado por Alan Kay en el Centro de Investigaciones Xerox de Palo Alto a principios de 1970, es un lenguaje muy influenciado por SIMULA. Es un lenguaje de programación reflexivo , orientado a objetos y con tipado dinámico. Por sus características, puede ser considerado como un entorno de objetos, donde incluso el propio sistema es un objeto. La primera versión de Smalltalk se conoce como Smalltalk-80, aunque hay una gran cantidad de variantes aún utilizadas hoy en día. Primero, se desarrolló Smalltalk-71, creada por un desarrollador llamado Dan Ingalls que pensó un lenguaje de programación basado en la idea de mensajes y que se podía reducir a una página de código. Pero estas versiones de Smalltalk eran bastante diferentes a lo que luego sería el producto final. Luego, se lanzó la versión Smalltalk-76. Esta versión contenía elementos ya conocidos por todos y que significaron un avance importante. Pero Smalltalk-80 fue el primer lenguaje que se hizo disponible fuera de Xerox PARC, repartido a compañías como Hewlett-Packard y, por supuesto, Apple, que para ese entonces ya era cercana a las investigaciones en el Centro. No solamente es importante, sino que podríamos decir que es fundamental para comprender a la computación de usuarios como la conocemos hoy en día. El concepto central de Smalltalk es el de objeto. Cuando ingresamos a un entorno de Smalltalk, no estamos haciendo una interacción directa con código, sino que lo hacemos en un entorno de objetos virtuales. Lo que hacemos es enviarles “mensajes” para esperar una respuesta. Por ende, Smalltalk consiste solamente de objetos. Todos los elementos del programa son considerados objetos que tienen 4 características comunes; memoria propia, comunicación con otros objetos, posibilidad de heredar las características de otros objetos, posibilidad de procesamiento. Por estar características, es considerado el primer lenguaje de programación orientado a objetos, que fue implementado en algunos productos importantes como Squeak, VisualWorks, Dolphin, y más. La herencia de Smalltalk es una de las más importantes de la programación, y no debería ser olvidada.

\subsection{Objetive-C}
Objetive-C fue creado por Brad Cox y la corporación StepStone en 1980. Es una ampliación del lenguaje C basado en las ideas de Smalltalk, pero resolviendo sus problemas de consumo de memoria y lentitud. En 1988 fue adoptado como lenguaje de programación de NEXTSTEP y en 1992 fue liberado bajo licencia GPL para el compilador GCC. En 1996 Apple adquirió NEXTSTEP y usó OpenStep en su sistema operativo Mac OS X, por lo que Objetive-C pasó a ser su lenguaje por defecto.

\subsection{Ada}

En 1975 el Departamento de Defensa de USA formó un equipo para evaluar los lenguajes existentes hasta el momento con el objetivo de encontrar uno que se adaptara a sus necesidades. El equipo concluyó que ninguno de los existentes cumplía los requerimientos necesarios por lo que se propuso la creación de un nuevo lenguaje que se basara en Pascal y ALGOL. Tiempo después se llevó a cabo un concurso para desarrollar un nuevo lenguaje que se ajustara a las necesidades. Al concurso se presentaron 17 lenguajes, de los cuales solo se seleccionaron 4 para la siguiente fase. A estas propuestas se les asignó los nombres de \textbf{Red, Green, Yellow} y \textbf{Blue}. El vencedor del concurso fue Green el cual fue diseñado por Jean Ichbiah. En un primer momento, se le dio el nombre de \textit{DoD-1} pero acabó cambiándose por ADA, en honor de Ada Lovelace. A pesar de los años que han pasado y las actualizaciones que ha tenido, no es un lenguaje popular. Es criticado por su complejidad y solo se le ve utilidad para el desarrollo de grandes softwares.

\subsection{Prolog}

Robert Kowalski y Alain Colmerauer y Phillippe Roussell tuvieron la idea de que la lógica matemática se podía usar como un lenguaje de programación. De esta idea nació Prolog \textit{(\textbf{PRO}gramation \textbf{LOG}ique)} que es un lenguaje de programación lógico, quizá uno de los más populares de este paradigma ya que fue el primero en implementarlo. Su primera versión fue programada en ALGOL y era un lenguaje totalmente interpretado, hasta que en 1983 David H.D Warren implementó un compilador al cual se le llamó \textit{Warren Abstract Machine(WAM)} y desde ese momento el lenguaje es semi-interpretado. Después de \textit{WAM} salieron a la luz otros compiladores entre ellos Turbo-Prolog que como es de esperar fue implementado por Borland. Este lenguaje no está orientado al cálculo científico, su aplicación está en la inteligencia artificial, estableciendo relaciones entre objetos y resolviendo problemas lógicos a partir de una base de conocimientos previamente definida.


\subsection{C++}
Fue diseñado a mediados de los años 80 por el danés Bjarne Stroustrup. Su intención fue la de extender el lenguaje de programación C con el objetivo de que tuviese los mecanismos necesarios para manipular objetos. También fue influido por lenguajes como Simula, Ada y ALGOL, por lo tanto, C++ contiene los paradigmas de la programación estructurada y orientada a objetos, por lo que se le conoce como un lenguaje de programación multiparadigma. A C++ primero se le conoció como C con clases y luego se cambió a C++ que significa incremento de C por el operador ++ de C, dando a entender que se trata de una extensión de dicho lenguaje. Algunas de las principales ventajas de programar en C++ son el alto rendimiento debido a que puede hacer llamadas directas al sistema operativo, es compilado para cada plataforma, posee gran variedad de parámetros de optimización y se integra de forma directa con el lenguaje ensamblador. C++ es un lenguaje robusto y bien diseñado que ha sabido actualizarse con el paso de los años. Su potencia y capacidad de programación en ensamblador le permite seguir siendo una de las mejores opciones para programar hoy en día.



\subsection{Perl}
En 1987 Larry Wall comenzó a trabajar en Perl y el 18 de diciembre de ese mismo año anunció la versión 1.0. Perl 2 fue publicado el próximo año, el cual agregó un mejor motor de expresiones regulares. Para 1989 ya se había presentado Perl 3 donde se agregó soporte para datos binarios. En 1991 fue publicado Programming Perl por O’Reilly siendo la portada del libro un dromedario quedando este como un referente de la documentación del lenguaje. Al mismo tiempo, se lanzó la versión 4 del lenguaje, no por marcar un gran cambio en el lenguaje, sino por identificar a la versión que estaba documentada en el libro. Perl 5 fue publicado el 17 de octubre de 1994. Fue casi una completa reescritura del intérprete y añadió muchas nuevas características al lenguaje, incluyendo objetos, referencias, paquetes y módulos. Los módulos proveen de un mecanismo para extender el lenguaje sin modificar el intérprete. Esto permitió estabilizar su núcleo principal, además de permitir a los programadores de Perl añadirle nuevas características. El diseño de Perl puede ser entendido como una respuesta a tres amplias tendencias de la industria informática: rebaja de los costes en el hardware, aumento de los costes laborales y las mejoras en la tecnología de compiladores. Anteriormente, lenguajes como Fortran y C, fueron concebidos para hacer un uso eficiente del hardware. Por otro lado, Perl fue diseñado para facilitar el trabajo de los programadores, aunque esto conlleve a unos requerimientos de CPU y memoria mayores. Estas incluyen gestión de memoria automática; tipo de dato dinámico; strings, listas y hashes; expresiones regulares; introspección y una función eval().

\subsection{Haskell}

Haskell es un lenguaje de programación estandarizado multi-propósito puramente funcional con semánticas no estrictas y fuerte tipificación estática. Su nombre se debe al lógico estadounidense Haskell Curry. En Haskell, "una función es un ciudadano de primera clase" del lenguaje de programación. Como lenguaje de programación funcional, el constructor de controles primario es la función. El lenguaje tiene sus orígenes en las observaciones de Haskell Curry y sus descendientes intelectuales.

En los años 1980 se constituyó un comité cuyo objetivo era crear un lenguaje funcional que reuniera las características de los múltiples lenguajes funcionales de la época, el más notable Miranda, y resolviera la confusión creada por la proliferación de los mismos.

Las características más interesantes de Haskell incluyen el soporte para tipos de datos y funciones recursivas, listas, tuplas, guardas y encaje de patrones. La combinación de las mismas pueden resultar en algunas funciones casi triviales cuya versión en lenguajes imperativos pueden llegar a resultar extremadamente tediosas de programar. Haskell es, desde 2002, uno de los lenguajes funcionales sobre los que más se ha investigado. Se han desarrollado muchas variantes:
\begin{itemize}

\item Versiones paralelas del MIT y Glasgow, ambas denominadas Parallel Haskell.
\item Más versiones paralelas y distribuidas de Haskell llamadas Distributed Haskell (anteriormente Goffin) y Eden
\item   Una versión con ejecución especulativa: Eager Haskell
    Varias versiones orientadas a objetos: Haskell++, O'Haskell y Mondrian.
\item Una versión educativa llamada Gofer desarrollada por Mark Jones que fue suplantada por Hugs.
    
\end{itemize}

\subsection{Visual Basic}

Visual Basic (VB) es un lenguaje de programación dirigido por eventos, desarrollado por Alan Cooper para Microsoft. Este lenguaje de programación es un dialecto de BASIC, con importantes agregados. Su primera versión fue presentada en 1991, con la intención de simplificar la programación utilizando un ambiente de desarrollo que facilitó en cierta medida la programación misma.

La última versión fue la 6, liberada en 1998, para la que Microsoft extendió el soporte hasta marzo de 2008.

En 2001 Microsoft propuso abandonar el desarrollo basado en la API Win32 y pasar a un framework o marco común de librerías, independiente de la versión del sistema operativo, .NET Framework, a través de Visual Basic .NET (y otros lenguajes como C Sharp de fácil transición de código entre ellos); fue el sucesor de Visual Basic 6.

Aunque Visual Basic es de propósito general, también provee facilidades para el desarrollo de aplicaciones de bases de datos usando Data Access Objects, Remote Data Objects o ActiveX Data Objects.

Visual Basic contiene un entorno de desarrollo integrado o IDE que integra editor de textos para edición del código fuente, un depurador, un compilador (y enlazador) y un editor de interfaces gráficas o GUI.

Visual Basic dio un paso más en innovación y ahora es posible programar aplicaciones Nativas para Android o IPhone utilizando un software de la compañía Anywhere Software que transforma código Visual Basic (creado por dicha compañía) en APPs 100 porciento nativas en Java para ambos sistemas operativos de dispositivos móviles.

\subsection{Eiffel}

Eiffel fue diseñado por Bertrand Meyer y sacado a la luz en 1985. Fue desarrollado por Eiffel Software cumpliendo las pautas de su diseñador, que más adelante lo llevarían a ser un punto de referencia para lenguajes como Java y C\#. El objetivo de diseño de Eiffel es permitir a los programadores desarrollar módulos de software fiables y reutilizables. Tiene características que revolucionaron ingeniería del Software como diseño por contratos el cual está estrechamente ligado a otras construcciones del lenguaje. También soporta herencia múltiple, polimorfismo, encapsulación, covarianza de los parámetros. Tiene recolector de basura y su sintaxis de palabras clave sigue la tradición ALGOL.


\subsection{Python}
La implementación de Python comenzó en diciembre de 1992 cuando en Navidad Guido Van Rossum que trabajaba en el (CWI) (un centro de investigación holandés de carácter oficial) decidió empezar el proyecto como un pasatiempo dándole continuidad al lenguaje de programación ABC del que había formado parte del equipo de desarrollo en el CWI, dicho lenguaje se enfocaba en ser fácil de usar y aprender manteniendo potencia en su desempeño pero el hardware disponible en la época de su creación hacía difícil su uso y el proyecto no trascendió como se esperaba. Así que Van Rossum le dio una segunda oportunidad creando Python. En 1991, Van Rossum publicó el código de la vesión 0.9.0. En esta versión ya se encontraba disponible clases con herencia, funciones y un manejo de excepciones y el sistema de módulos adoptados de Modula-3. Su versión 1.0 llegó el año 1994, la cual incluyó herramientas de programación funcional como lambda, reduce, filter y map que son características extraídas de lenguajes funcionales. Para la versión 2.0 se incluyó la generación de listas, una de las características más importantes de Haskell y además un sistema de recolección de basura capaz de recolectar referencias cíclicas. La versión 3.0 salió a la luz durante el 2008. Las versiones 3.x y 2.x fueron planeadas para coexistir por varios releases que se lanzaron en paralelo, donde Python 2.6 se lanzó junto con 3.0. De igual manera 2.7 fue lanzado junto con 3.1. Actualmente la versión 2.7 solo recibe actualizaciones de seguridad debido a que dejará de tener soporte el año 2020. Entre las características más notables de Python se encuentran que es un lenguaje de propósito general, es multiparadigma, multiplataforma, de tipado dinámico y orientado a objetos; también nos encontramos con la capacidad de desarrollar librerías en C o C++, lo cual ha traído gran aceptación entre los programadores ya que pueden aprovechar la velocidad de estos lenguajes para sus algoritmos.

\subsection{PHP}

Creado por Rasmus Lerdorf en 1995, la primera encarnación de PHP era un conjunto simple de ficheros binarios Common Gateway Interface (CGI) escritos en el lenguaje de programación C. Originalmente utilizado para rastrear visitas de su currículum online, llamó al conjunto de scripts "Personal Home Page Tools", más frecuentemente referenciado como "PHP Tools". Es un lenguaje de propósito general de código del lado del servidor, con mucha aplicación en el desarrollo web de contenido dinámico, marcando un antes y un después en el proceso evolutivo de las aplicaciones en línea. La sintaxis del lenguaje se basa en la de C, el intérprete solo ejecuta el código que se encuentra entre sus delimitadores <? php (codigo) ?>. 


\subsection{JAVA}

Java es un lenguaje de programación de propósito general, concurrente, orientado a objetos que fue diseñado específicamente para tener tan pocas dependencias de implementación como fuera posible. Su intención es permitir que los desarrolladores de aplicaciones escriban el programa una vez y lo ejecuten en cualquier dispositivo (conocido en inglés como WORA, o "write once, run anywhere"), lo que quiere decir que el código que es ejecutado en una plataforma no tiene que ser recompilado para correr en otra. Java es, a partir de 2012, uno de los lenguajes de programación más populares en uso, particularmente para aplicaciones de cliente-servidor de web, con unos 10 millones de usuarios reportados.

El lenguaje de programación Java fue originalmente desarrollado por James Gosling de Sun Microsystems (la cual fue adquirida por la compañía Oracle) y publicado en 1995 como un componente fundamental de la plataforma Java de Sun Microsystems. Su sintaxis deriva en gran medida de C y C++, pero tiene menos utilidades de bajo nivel que cualquiera de ellos. Las aplicaciones de Java son generalmente compiladas a bytecode (clase Java) que puede ejecutarse en cualquier máquina virtual Java (JVM) sin importar la arquitectura de la computadora subyacente.

La compañía Sun desarrolló la implementación de referencia original para los compiladores de Java, máquinas virtuales, y librerías de clases en 1991 y las publicó por primera vez en 1995. A partir de mayo de 2007, en cumplimiento con las especificaciones del Proceso de la Comunidad Java, Sun volvió a licenciar la mayoría de sus tecnologías de Java bajo la Licencia Pública General de GNU. Otros también han desarrollado implementaciones alternas a estas tecnologías de Sun, tales como el Compilador de Java de GNU y el GNU Classpath.

\subsection{C$\#$}

C$\#$(pronunciado si sharp en inglés) es un lenguaje de programación orientado a objetos desarrollado y estandarizado por Microsoft como parte de su plataforma .NET, que después fue aprobado como un estándar por la ECMA (ECMA-334) e ISO (ISO/IEC 23270). C$\#$ es uno de los lenguajes de programación diseñados para la infraestructura de lenguaje común.

Su sintaxis básica deriva de C/C++ y utiliza el modelo de objetos de la plataforma .NET, similar al de Java, aunque incluye mejoras derivadas de otros lenguajes.

El nombre C Sharp fue inspirado por la notación musical, donde $\#$ (sostenido, en inglés sharp) indica que la nota (C es la nota do en inglés) es un semitono más alta, sugiriendo que C$\#$ es superior a C/C++. Además, el signo $\#$ se compone de cuatro signos '+' pegados.

Aunque C$\#$ forma parte de la plataforma .NET, ésta es una API, mientras que C$\#$ es un lenguaje de programación independiente diseñado para generar programas sobre dicha plataforma. Ya existe un compilador implementado que provee el marco Mono - DotGNU, el cual genera programas para distintas plataformas como Windows, Unix, Android, iOS, Windows Phone, Mac OS y GNU/
Linux.

\subsection{Go}

Go también es conocido como Goland y es un, nada más y nada menos que, un lenguaje de programación diseñado por Google. Está inspirado en C, pero es un lenguaje bastante más complicado.

Está enfocado a procesos muy concretos, pero el objetivo principal es la seguridad. Por eso, Go no tiene aritmética de punteros. Siendo de Google, en cuanto se empiece a popularizar, seguro que gana un importante hueco en el desarrollo de Android.


Go es un lenguaje de programación concurrente y compilado inspirado en la sintaxis de C. Ha sido desarrollado por Google, y sus diseñadores iniciales son Robert Griesemer, Rob Pike y Ken Thompson. Actualmente está disponible en formato binario para los sistemas operativos Windows, GNU/Linux, FreeBSD y Mac OS X, pudiendo también ser instalado en estos y en otros sistemas con el código fuente. Go es un lenguaje de programación compilado, concurrente, imperativo, estructurado, orientado a objetos y con recolector de basura que de momento está soportado en diferentes tipos de sistemas UNIX, incluidos Linux, FreeBSD, Mac OS X y Plan 9 (puesto que parte del compilador está basado en un trabajo previo sobre el sistema operativo Inferno). Las arquitecturas soportadas son i386, amd64 y ARM.


\subsection{Dart}

Dart (originalmente llamado Dash) es un lenguaje de programación de código abierto, desarrollado por Google. Fue revelado en la conferencia goto; en Aarhus, Dinamarca el 10 octubre de 2011. El objetivo de Dart no es reemplazar JavaScript como el principal lenguaje de programación web en los navegadores web, sino ofrecer una alternativa más moderna. El espíritu del lenguaje puede verse reflejado en las declaraciones de Lars Bak, ingeniero de software de Google, que define a Dart como un “lenguaje estructurado pero flexible para programación Web”.

\subsection{Julia}

Julia es un lenguaje de programación homoicónico, multiplataforma y multiparadigma de tipado dinámico de alto nivel y alto desempeño para la computación genérica, técnica y científica, con una sintaxis similar a la de otros entornos de computación similares. El nombre del lenguaje Julia fue una ocurrencia de los creadores.

Dispone de un compilador avanzado (JIT), mecanismos para la ejecución en paralelo y distribuida, además de una extensa biblioteca de funciones matemáticas. La biblioteca, desarrollada fundamentalmente en Julia, también contiene código desarrollado en C o Fortran,6 para el álgebra lineal, generación de números aleatorios, procesamiento de señales, y procesamiento de cadenas. Adicionalmente, la comunidad de desarrolladores de Julia contribuye con la creación y distribución de paquetes externos a través del gestor de paquetes integrado de Julia a un paso acelerado. Julia es el resultado de la colaboración entre las comunidades de IPython y Julia, provee de una poderosa interfaz gráfica basada en el navegador para Julia. 

\subsection{Rust}

Rust es un lenguaje de programación compilado, de propósito general y multiparadigma que está siendo desarrollado por Mozilla. Ha sido diseñado para ser "un lenguaje seguro, concurrente y práctico". Es un lenguaje de programación multiparadigma que soporta programación funcional pura, por procedimientos, imperativa y orientada a objetos.

El lenguaje surgió de un proyecto personal desarrollado por Graydon Hoare (trabajador de Mozilla), quien empezó a trabajar en él en 2006; Mozilla se involucró en este proyecto en 2009 y lo dio a conocer oficialmente en 2010. Ese mismo año, el trabajo pasó del compilador inicial (escrito en OCaml) al compilador autocontenido, escrito en sí mismo. Conocido como rustc, en 2011 se compiló a sí mismo. El compilador autocontenido usa LLVM como su back-end.

La primera versión alfa numerada del compilador de Rust apareció en enero de 2012. La versión 1.0 fue lanzada el 15 de mayo de 2015.

Según la política de Mozilla, Rust es desarrollado de forma totalmente abierta y busca la opinión y contribución de la comunidad. El diseño del lenguaje se ha ido perfeccionando a través de las experiencias en el desarrollo del motor de navegador Servo, y el propio compilador de Rust. Aunque es desarrollado y patrocinado por Mozilla y Samsung, es un proyecto comunitario. Una gran parte de las contribuciones proceden de los miembros de la comunidad.

\subsection{Swift}
El desarrollo de Swift comenzó con Chris Lattner en el 2010, tomando ideas de lenguajes famosos como Objetive-c, Haskell, Rust, Ruby, Python, C\#, entre otros. Salió al mundo bajo la marca de Apple el 2014 en la \textit{Worldwide Developers Conference (WWDC)}. Es un lenguaje de programación multiparadigma y está diseñado para integrarse con los Frameworks Cocoa y Cocoa Touch, también puede usar cualquier biblioteca implementada en Objetive-c y funciones de C. En el 2015 se presentó su versión 2.2 y pasó a ser código abierto bajo Licencia Apache. Es fuertemente tipado y presenta inferencia de tipos. Sus tipos se dividen en dos grupos, los tipos por valor y los tipos por referencia, al igual que C\#.

%------------------------------------------------

\section{Tendencias actuales}

La evolución de los lenguajes de programación continúa, tanto en la industria como en investigación. Algunas de las tendencias actuales incluyen:

    Aumentar el soporte para la programación funcional en lenguajes importantes utilizados comercialmente, incluida la programación funcional pura para hacer el código más fácil de razonar y de paralelizar (tanto en macro como en micro-niveles).
    Construir lenguajes para apoyar la programación concurrente y distribuida.
    Mecanismos para añadir al lenguaje verificación en cuanto a seguridad y confiabilidad: chequeo sintáctico extendido, control de flujo de información, seguridad de hilos.
    Mecanismos alternativos de modularidad: mixins, delegados, aspectos.
    Desarrollo de software orientado a componentes.
    Metaprogramación, la reflexión o el acceso al árbol de sintaxis abstracta.
    Mayor énfasis en cuanto a distribución y movilidad.
    Integración con bases de datos, incluyendo XML y bases de datos relacionales.
    Soporte para Unicode para que el código fuente (texto del programa) no se limite sólo a los caracteres contenidos en el conjunto de caracteres ASCII, permitiendo, por ejemplo, el uso de caracteres no latinos basados en guiones o signos de puntuación extendidos.
    XML para interfaz gráfica (XUL, XAML).
    El código abierto como una filosofía de desarrollo de lenguajes, incluyendo la colección de compiladores de GNU y lenguajes recientes, como Python, Ruby, y Squeak.
    Programación Orientada a Aspectos (AOP).
    Lenguajes que soporten programar sobre los procesadores de la GPU en paralelo, como OpenCL.





%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------

\begin{thebibliography}{99} % Bibliography - this is intentionally simple in this template

\bibitem[Sebesta, Robert W.
Concepts of programming languages / Robert W. Sebesta. 10th ed.]{}
\bibitem[Historia y evolución
de los lenguajes
de programación. Vicente Trigo Aranda]{}
\bibitem[Evolucion de los lenguajes de programación. Fercho Nava]{}
\bibitem[Evolucion historica de los lenguajes de programación]{}
\bibitem[Wikipedia/Historia de los lenguajes de programación]{}
\end{thebibliography}

%----------------------------------------------------------------------------------------

\end{document}
